# java-test
## CacheMap
* На CacheMap около 6 часов, из них первый на прохождение тестов и остальные 5 на корректное удаление всех записей. 
* Хотелось добиться близкого к O(1) результату операций с Map не взирая на операции очистки не актуальных записей.
Как мне кажется, мне удалось приблизиться к константному времени
* Неясно было в каком режиме будет использвоаться кэш, (скажем постоянно льется +- одинаковый поток, или есть пиковые нагрузки. Мой вариант скорей всего может упасть с OOM на пиках, если размер хипа не достаточен.)
* Из принципа не ходил в guava и другие имплементации кэшей, было интересно заколхозить свой вариант, понятно, что если бы нужна была своя самописная реализация, то я бы начал с изучения вопроса
 
## Refactoring
* На рефакторинг ушло около двух часов 
* Не понял что было в статическом методе который дергал запрос getAll, если предположить что это был хелсчек базы, то реализовывал бы его бутовым актуатором, но так как какого то внешнего интерфейса к системе не было, то реализовал просто библиотекой
* Неясны куски неиспользуемого кода в рефакторинге, я его просто выкидывал,  так как не понял намерений (если это должно было подниматься как севис, слушать соединения например)

#Performance tester
* На тестер производительности ушло 1,5 часа
* Выбор Fork\Join продиктован тем, что как мне кажется сама задача хорошо ложится на  map\reduce (собрать результаты тредов, потом скомбинировать в один общий результат) Простой fixecThreadPool был бы более предсказуем
* Меня смущают пики максимального времени в районе 70ms в то время как мокнутый Runnable отдает по максимуму 10 ms, но это можно списать на то, что я мокал реализацию из груви, может как он не совсем эффективно скомпилилось
* Делал с warmup, но не заморачивался на -XX:+PrintCompilation, -verbose:gc -server итп так что не факт что оно еще что то не до компиливает,
* Использовал nanoTime потмоу что есть методы которые отрабатывают и меньше чем за 1 мс, но по скольку результат в long разницы в этом особо нет
* Если бы нужно было делать бенчмарки я бы использовал что то уже написанное

